[{"title":"嵌入式小知识","path":"/2025/06/24/嵌入式小知识/","content":"##定时器篇 频率与周期关系频率（f)：每秒发生的次数（单位Hz) 公式：T1f周期（T)：每次发生的时间间隔（单位：秒m）\t公式：f1T示例：20HZ的频率对应周期：T1200.05秒50毫秒1ms的周期对应频率：f10.0011000Hz1KHz定时器公式的两种形式 形式1：计算频率（单位：Hz)公式：更新频率(f)时钟频率（设备主时钟）（预分频值）（自动重装值）更新频率＝72MHz（主时钟：以72M为例），预分频＝72-1．重装载值＝1000-1计算过程：f＝72000000(72-1)(1000-1)7200000072*10001000Hz 形式2：计算时间（单位：秒）公式：更新周期（T)（预分频值）（自动重装值)时钟频率（设备主时钟）时钟频率＝72MHz（主时钟：以72M为例），预分频：72-1. 重裝载值：1000-1计算过程：T＝(72-1)(1000-1)7200000072000720000000.001秒 0.001*10001秒 名词解释：预分频英文和结构体：PSC，TIM_Prescaler． 重装载值的英文和结构体：ARR,TIM_Period. 设备主时钟：以STM32F103x8举例来说：设备主时钟为：72MHz"},{"title":"PID资料","path":"/2025/06/23/PID资料/","content":"##PID循迹 ###PID加权循迹 // 停车控制变量bool stop_flag = false;uint8_t stop_counter = 0;const uint8_t STOP_THRESHOLD = 3; // 连续5次全检测才停车// 加权偏移计算函数int8_t Calculate_Weighted_Offset(uint8_t sensor_state) // 检查是否所有传感器都检测到（停车条件） if (sensor_state == 0xFF) stop_counter++; if (stop_counter = STOP_THRESHOLD !stop_flag) stop_flag = true; // 设置停车标志 // 执行停车动作 Motor_Trace(0, 0); // 立即停止电机 return 0; // 返回0偏移，但此时停车标志已触发 else stop_counter = 0; // 重置停车计数器 int16_t weighted_sum = 0; //计数加权值变量 uint8_t active_count = 0; //记录传感器使用数量 static uint8_t lost_count = 0; //丢线次数记录变量 static int8_t last_valid_offset = 0; //记录上次有效偏移 // 检查每个传感器的状态 for (int i = 0; i 8; i++) uint8_t bit_mask = 1 i; if (sensor_state bit_mask) weighted_sum += SENSOR_WEIGHTS[i]; active_count++; // 处理丢线情况 if (active_count == 0) lost_count++; if (lost_count 10) return 0; // 完全丢线 return last_valid_offset; // 使用上次有效偏移 lost_count = 0; // 重置丢线计数器 // 计算归一化偏移量 (-100 ~ +100) // 最大可能值：7*100/7 = 100 int8_t offset = (weighted_sum * 100) / 7; // 保存有效偏移 last_valid_offset = offset; return offset;// Trace_Collect函数（返回误差）int8_t Trace_Collect(void) // 如果已停车，返回0偏移 if (stop_flag) return 0; // 获取当前传感器状态 uint8_t sensor_state = Trace; // 计算加权偏移量 int8_t offset = Calculate_Weighted_Offset(sensor_state); return offset;// 设置电机速度（使用循迹模式指令0x06）//使用的电机驱动板void Apply_PID_Output(int8_t pid_output) // 如果已停车，直接返回 if (stop_flag) return; // 动态基础速度：根据偏移量调整 uint8_t base_speed = 180; // 基础速度值 int8_t abs_offset = abs(Tare_OUT.Actual); // 偏移越大（弯道），速度越低 if (abs_offset 50) base_speed = 130; // 急弯降速 else if (abs_offset 30) base_speed = 150; // 中弯降速 // 计算差速 uint8_t left_speed = base_speed - pid_output; uint8_t right_speed = base_speed + pid_output; // 限幅处理 (0-200) left_speed = (left_speed 200) ? 200 : left_speed; right_speed = (right_speed 200) ? 200 : right_speed; // 使用循迹模式指令 Motor_Trace(right_speed, left_speed);//定时器函数（参考） 调控周期：5毫秒时间void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) if (htim-Instance == TIM5) if (stop_flag) Leave_Flay = 1; return; Tare_OUT.Actual = Trace_Collect(); PID_Update(Tare_OUT); Apply_PID_Output(Tare_OUT.Out); // printf(%d,%d,Tare_OUT.Actual,Tare_OUT.Out); ##PID参考代码 //*江协科技示列代码*////PID.C#include PID.h/** * 函 数：PID计算及结构体变量值更新 * 参 数：PID_t * 指定结构体的地址 * 返 回 值：无 */void PID_Update(PID_t *p)\t/*获取本次误差和上次误差*/\tp-Error1 = p-Error0; //获取上次误差\tp-Error0 = p-Target - p-Actual; //获取本次误差，目标值减实际值，即为误差值 /*外环误差积分（累加）*/\t/*如果Ki不为0，才进行误差积分，这样做的目的是便于调试*/\t/*因为在调试时，我们可能先把Ki设置为0，这时积分项无作用，误差消除不了，误差积分会积累到很大的值*/\t/*后续一旦Ki不为0，那么因为误差积分已经积累到很大的值了，这就导致积分项疯狂输出，不利于调试*/\tif (p-Ki != 0) //如果Ki不为0 p-ErrorInt += p-Error0;\t//进行误差积分 else //否则 p-ErrorInt = 0; //误差积分直接归0 /*PID计算*/\t/*使用位置式PID公式，计算得到输出值*/\tp-Out = p-Kp * p-Error0 + p-Ki * p-ErrorInt + p-Kd * (p-Error0 - p-Error1); /*输出限幅*/\tif (p-Out p-OutMax) p-Out = p-OutMax;\t//限制输出值最大为结构体指定的OutMax\tif (p-Out p-OutMin) p-Out = p-OutMin;\t//限制输出值最小为结构体指定的OutMin/*循迹PID*/int Position_PID (int Encoder,int Target) //差速PID控制器//这里Encoder=error，Target=0; float Position_KP=1.5,Position_KI=0,Position_KD=0;//这里未使用到Ki static float Bias=0,Pwm=0,Integral_bias=0,Last_Bias=0; Bias=Encoder-Target; //20 //0 //计算偏差 Integral_bias+=Bias; //求出偏差的积分 Pwm=Position_KP*Bias+Position_KI*Integral_bias+Position_KD*(Bias-Last_Bias);//0-20 //位置式PID控制器 Last_Bias=Bias; //20 0 //保存上一次偏差 return Pwm;\t//返回PWM值//PID.H#ifndef __PID_H#define __PID_Htypedef struct float Target;\tfloat Actual;\tfloat Out; float Kp;\tfloat Ki;\tfloat Kd; float Error0;\tfloat Error1;\tfloat ErrorInt; float OutMax;\tfloat OutMin; PID_t;void PID_Update(PID_t *p);int Position_PID (int Encoder,int Target);#endif//*参考网上资料参数（可以使用）*//int Position_PID(int Encoder, int Target) float Position_KP = 650, Position_KI = 0, Position_KD = 7300; static float Bias = 0, Pwm = 0, Integral_bias = 0, Last_Bias = 0; Bias = Encoder - Target; Integral_bias += Bias; Pwm = Position_KP * Bias + Position_KI * Integral_bias + Position_KD * (Bias - Last_Bias); Last_Bias = Bias; return Pwm; PID调参篇 个人调参经验：先调P值，直到被控目标出现震荡，然后缩小一些P值，查看调控目标是否到达预定位置，如果差别多就增加i值，i值加到数据出现超调时，就停止i值的增加，调大d值给被控物体增加阻尼，减小超调 PID使用注意事项 使用PID进行调控时，我们需要注意PID的调控周期。合适的调控周期会给我们的控制物品带来更加稳定的效果。 （但调控周期要比误差获取的时间快，不然会导致使用错误的误差（实际值）调整错误的参数，最后失控）。PID调控时间可以使用循环也可以使用定时器，需要根据控制物品所决定。"},{"title":"STM32VScode笔记","path":"/2025/06/22/STM32_VScode笔记/","content":":Cmake生成Complie_commands.jsoncmake -DCMAKE_EXPORT_COMPILE_COMMANDS=ON :Cmake生成Complie_commands.jsoncmake -S . -B build -GNinja -DCMAKE_EXPORT_COMPILE_COMMANDS=1 :串口重定向:GCC编译器#include stdio.hint _write(int fd, char *pBuffer, int size) while (__HAL_UART_GET_FLAG(huart1, UART_FLAG_TC) == 0); HAL_UART_Transmit(huart1, (uint8_t *)pBuffer, size, 0xff); return size; :Cmake生成hex bin文件# 添加生成 .hex 和 .bin 文件的自定义命令add_custom_command(TARGET $CMAKE_PROJECT_NAME POST_BUILD COMMAND $CMAKE_OBJCOPY -O ihex $TARGET_FILE:$CMAKE_PROJECT_NAME $CMAKE_BINARY_DIR/$CMAKE_PROJECT_NAME.hex COMMAND $CMAKE_COMMAND -E echo Generating $CMAKE_PROJECT_NAME.hex COMMAND_EXPAND_LISTS COMMAND $CMAKE_OBJCOPY -O binary -S $TARGET_FILE:$CMAKE_PROJECT_NAME $CMAKE_BINARY_DIR/$CMAKE_PROJECT_NAME.bin COMMAND $CMAKE_COMMAND -E echo Generating $CMAKE_PROJECT_NAME.bin COMMAND_EXPAND_LISTS COMMENT Generating hex and bin files VERBATIM)"},{"title":"Hello World","path":"/2025/06/22/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new My New Post More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment 。"},{"title":"面试资料","path":"/2025/04/17/面试笔记/","content":"STM32 有几个栈单核芯片就只有两个栈，主栈和进程；双核芯片，STM32H750等，双核芯片就有四个任务栈，同样是每个核有一个主栈和一个任务栈。 **主栈：**用于异常处理和中断服务程序等对实时性要求较高的应用场景，它的优先级较高。 **进程栈：**用于普通程序的执行流程，如函数调用、局部变量储存等。"}]